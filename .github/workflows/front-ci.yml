name: Frontend CI

on:
  push:
    branches: [fe/develop, fe/production]
  pull_request:
    branches: [fe/develop, fe/production]

defaults:
  run:
    working-directory: ./frontend

jobs:
  type-check:
    runs-on: ubuntu-latest
    if: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Type Check
        run: npm run type-check

  lint:
    runs-on: ubuntu-latest
    if: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

  test:
    runs-on: ubuntu-latest
    if: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Run Tests
        run: npm test
        env:
          CI: true

  build-dev:
    runs-on: ubuntu-latest
    # needs: [type-check, lint, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build:dev

  build-prod:
    runs-on: ubuntu-latest
    needs: [type-check, lint, test]
    if: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build:prod

  lighthouse:
    runs-on: ubuntu-latest
    needs: [build-dev]
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      pull-requests: write
    defaults:
      run:
        working-directory: ./frontend
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: "./frontend/package-lock.json"

      - name: Cache node_modules
        uses: actions/cache@v4
        id: npm-cache
        with:
          path: |
            **/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build:dev

      - name: Run Lighthouse CI for Desktop
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
        run: |
          npm install -g @lhci/cli
          lhci collect --config=lighthouserc.cjs || echo 'Fail to Run Lighthouse CI ðŸ’¦'
          lhci upload --config=lighthouserc.cjs || echo 'Fail to Run Lighthouse CI ðŸ’¦'

      - name: Debug Lighthouse Results
        run: |
          echo "=== Checking lighthouse-results directory ==="
          ls -la lighthouse-results/ || echo "lighthouse-results directory not found"
          echo "=== Checking lighthouse-results-mobile directory ==="
          ls -la lighthouse-results-mobile/ || echo "lighthouse-results-mobile directory not found"
          echo "=== Current directory contents ==="
          ls -la

      - name: Run Lighthouse CI for Mobile
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
        run: |
          lhci collect --config=lighthouserc.mobile.cjs || echo 'Fail to Run Lighthouse CI Mobile ðŸ’¦'
          lhci upload --config=lighthouserc.mobile.cjs || echo 'Fail to Run Lighthouse CI Mobile ðŸ’¦'

      - name: Format lighthouse score
        id: format_lighthouse_score
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            process.chdir('./frontend');

            const { getLhciPageNameFromUrl, LHCI_GREEN_MIN_SCORE, LHCI_ORANGE_MIN_SCORE, LHCI_RED_MIN_SCORE } = require('./lighthouse.config.cjs');

            const getColor = (score) => {
              if (score >= LHCI_GREEN_MIN_SCORE) return 'ðŸŸ¢';
              else if (score >= LHCI_ORANGE_MIN_SCORE) return 'ðŸŸ ';
              return 'ðŸ”´';
            };

            const getAuditColorAndScore = (score) => getColor(score) + score;
            const getPerformanceMetricColorAndScore = (category) => getColor(category.score * 100) + category.displayValue;

            const formatResult = (res) => Math.round(res * 100);

            const desktopResultsDir = 'lighthouse-results';
            const mobileResultsDir = 'lighthouse-results-mobile';

            let desktopResults = [];
            if (fs.existsSync(desktopResultsDir)) {
              const desktopFiles = fs.readdirSync(desktopResultsDir)
                .filter(file => file.endsWith('.json'))
                .map(file => path.join(desktopResultsDir, file));
              
              desktopResults = desktopFiles.map(file => {
                const content = JSON.parse(fs.readFileSync(file, 'utf8'));
                return {
                  url: content.finalUrl || content.requestedUrl || content.mainDocumentUrl || '',
                  jsonPath: file,
                  report: content
                };
              });
            }

            let mobileResults = [];
            if (fs.existsSync(mobileResultsDir)) {
              const mobileFiles = fs.readdirSync(mobileResultsDir)
                .filter(file => file.endsWith('.json'))
                .map(file => path.join(mobileResultsDir, file));
              
              mobileResults = mobileFiles.map(file => {
                const content = JSON.parse(fs.readFileSync(file, 'utf8'));
                return {
                  url: content.finalUrl || content.requestedUrl || content.mainDocumentUrl || '',
                  jsonPath: file,
                  report: content
                };
              });
            }

            const monitoringTime = new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
            const scoreDescription = `> ðŸŸ¢: ${LHCI_GREEN_MIN_SCORE} - 100` + ' / ' + `ðŸŸ : ${LHCI_ORANGE_MIN_SCORE} - ${LHCI_GREEN_MIN_SCORE - 1}` + ' / ' + `ðŸ”´: ${LHCI_RED_MIN_SCORE} - ${LHCI_ORANGE_MIN_SCORE - 1}`;
            let comments = '';

            comments += `### Lighthouse report âœ¨\n`;
            comments += `${scoreDescription}\n\n`;

            const scores = { desktop: {}, mobile: {} };

            const extractLhciResults = (results, device) => {
              comments += `#### ${device}\n\n`;

              results.forEach((result) => {
                const { url, report } = result;
                const { categories, audits } = report;

                if (!url) {
                  console.log('URL is undefined for result:', result);
                  return;
                }

                const pageUrl = url.replace(/^http:\/\/localhost:\d+/, '');
                const pageName = getLhciPageNameFromUrl(pageUrl);

                const summary = {
                  performance: categories.performance.score,
                  accessibility: categories.accessibility.score,
                  'best-practices': categories['best-practices'].score,
                  seo: categories.seo.score,
                  pwa: categories.pwa ? categories.pwa.score : 0
                };

                Object.keys(summary).forEach((key) => (summary[key] = formatResult(summary[key])));

                const { performance, accessibility, 'best-practices': bestPractices, seo, pwa } = summary;
                const { 'first-contentful-paint': firstContentfulPaint, 'largest-contentful-paint': largestContentfulPaint, 'speed-index': speedIndex, 'total-blocking-time': totalBlockingTime, 'cumulative-layout-shift': cumulativeLayoutShift } = audits;

                const formattedScoreTable = [
                  `| Category | Score |`,
                  `| --- | --- |`,
                  `| ${getColor(performance)} Performance | ${performance} |`,
                  `| ${getColor(accessibility)} Accessibility | ${accessibility} |`,
                  `| ${getColor(bestPractices)} Best practices | ${bestPractices} |`,
                  `| ${getColor(seo)} SEO | ${seo} |`,
                  `| ${getColor(pwa)} PWA | ${pwa} |`,
                  `| ${getColor(firstContentfulPaint.score * 100)} First Contentful Paint | ${firstContentfulPaint.displayValue} |`,
                  `| ${getColor(largestContentfulPaint.score * 100)} Largest Contentful Paint | ${largestContentfulPaint.displayValue} |`,
                  `| ${getColor(speedIndex.score * 100)} Speed Index | ${speedIndex.displayValue} |`,
                  `| ${getColor(totalBlockingTime.score * 100)} Total Blocking Time | ${totalBlockingTime.displayValue} |`,
                  `| ${getColor(cumulativeLayoutShift.score * 100)} Cumulative Layout Shift | ${cumulativeLayoutShift.displayValue} |`,
                  `\n`
                ].join('\n');

                const score = {
                  Performance: getAuditColorAndScore(performance),
                  Accessibility: getAuditColorAndScore(accessibility),
                  'Best Practices': getAuditColorAndScore(bestPractices),
                  SEO: getAuditColorAndScore(seo),
                  PWA: getAuditColorAndScore(pwa),
                  FCP: getPerformanceMetricColorAndScore(firstContentfulPaint),
                  LCP: getPerformanceMetricColorAndScore(largestContentfulPaint),
                  'Speed Index': getPerformanceMetricColorAndScore(speedIndex),
                  TBT: getPerformanceMetricColorAndScore(totalBlockingTime),
                  CLS: getPerformanceMetricColorAndScore(cumulativeLayoutShift)
                };

                scores[device.toLowerCase()][pageName] = score;

                comments += `<details>\n<summary>${pageName}</summary>\n\n> ${pageUrl}\n\n${formattedScoreTable}\n</details>\n\n`;
              });
            };

            if (desktopResults.length > 0) {
              extractLhciResults(desktopResults, 'Desktop');
            }
            if (mobileResults.length > 0) {
              extractLhciResults(mobileResults, 'Mobile');
            }

            core.setOutput('comments', comments);
            core.setOutput('monitoringTime', monitoringTime);
            core.setOutput('scores', scores);

      - name: Comment PR
        uses: actions/github-script@v7
        with:
          script: |
            const { data: previousComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number
            });

            const previousLhciComment = previousComments.find((comment) => 
              comment.body.startsWith(`### Lighthouse report âœ¨\n`)
            );

            const newComment = `${{ steps.format_lighthouse_score.outputs.comments }}`;

            if (previousLhciComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: previousLhciComment.id,
                body: newComment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: newComment
              });
            }

      - name: Install required packages
        run: npm install google-spreadsheet

      - name: Update Google SpreadSheet
        run: node ./frontend/scripts/update-google-sheet.js
        env:
          LHCI_GOOGLE_CLIENT_EMAIL: ${{ secrets.LHCI_GOOGLE_CLIENT_EMAIL }}
          LHCI_GOOGLE_PRIVATE_KEY: ${{ secrets.LHCI_GOOGLE_PRIVATE_KEY }}
          LHCI_GOOGLE_SPREAD_SHEET_ID: ${{ secrets.LHCI_GOOGLE_SPREAD_SHEET_ID }}
          LHCI_SCORES: ${{ steps.format_lighthouse_score.outputs.scores }}
          LHCI_MONITORING_TIME: ${{ steps.format_lighthouse_score.outputs.monitoringTime }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
